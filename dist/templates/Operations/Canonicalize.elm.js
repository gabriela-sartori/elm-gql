"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (function () { return "module GraphQL.Operations.Canonicalize exposing (canonicalize, cyan, doTypesMatch, errorToString)\n\n{-| -}\n\nimport Dict exposing (Dict)\nimport Generate.Path\nimport GraphQL.Operations.AST as AST\nimport GraphQL.Operations.CanonicalAST as Can\nimport GraphQL.Operations.Canonicalize.Cache as Cache\nimport GraphQL.Operations.Canonicalize.UsedNames as UsedNames\nimport GraphQL.Schema\nimport Utils.String\n\n\ntype Error\n    = Error\n        { coords : Coords\n        , error : ErrorDetails\n        }\n\n\ntodo : String -> Error\ntodo msg =\n    Error\n        { coords =\n            { start = zeroPosition\n            , end = zeroPosition\n            }\n        , error = Todo msg\n        }\n\n\nerror : ErrorDetails -> Error\nerror deets =\n    Error\n        { coords = { start = zeroPosition, end = zeroPosition }\n        , error = deets\n        }\n\n\nzeroPosition : Position\nzeroPosition =\n    { line = 0\n    , char = 0\n    }\n\n\ntype alias Coords =\n    { start : Position\n    , end : Position\n    }\n\n\ntype alias Position =\n    { line : Int\n    , char : Int\n    }\n\n\ntype ErrorDetails\n    = QueryUnknown String\n    | EnumUnknown String\n    | ObjectUnknown String\n    | InterfaceUnknown String\n    | UnionUnknown String\n    | UnknownArgs\n        { field : String\n        , unknownArgs : List String\n        , allowedArgs : List GraphQL.Schema.Argument\n        }\n    | EmptySelection\n        { field : String\n        , fieldType : String\n        , options : List { field : String, type_ : String }\n        }\n    | FieldUnknown\n        { object : String\n        , field : String\n        }\n    | VariableIssueSummary VariableSummary\n    | FragmentVariableIssue FragmentVariableSummary\n    | FieldAliasRequired\n        { fieldName : String\n        }\n    | NonExhaustiveVariants\n        { unionName : String\n        , leftOver : List String\n        }\n    | MissingTypename\n        { tag : String\n        }\n    | EmptyUnionVariantSelection\n        { tag : String\n        }\n    | IncorrectInlineInput\n        { schema : GraphQL.Schema.Type\n        , arg : String\n        , found : AST.Value\n        }\n    | FragmentNotFound\n        { found : String\n        , object : String\n        , options :\n            List Can.Fragment\n        }\n    | FragmentTargetDoesntExist\n        { fragmentName : String\n        , typeCondition : String\n        }\n    | FragmentDuplicateFound\n        { firstName : String\n        , firstTypeCondition : String\n        , firstFieldCount : Int\n        , secondName : String\n        , secondTypeCondition : String\n        , secondFieldCount : Int\n        }\n    | FragmentSelectionNotAllowedInObjects\n        { fragment : AST.InlineFragment\n        , objectName : String\n        }\n    | FragmentInlineTopLevel\n        { fragment : AST.InlineFragment\n        }\n    | Todo String\n\n\ntype alias VariableSummary =\n    { declared : List DeclaredVariable\n    , valid : List Can.VariableDefinition\n    , issues : List VarIssue\n    , suggestions : List SuggestedVariable\n    }\n\n\ntype alias FragmentVariableSummary =\n    { fragmentName : String\n    , declared : List { name : String, type_ : String }\n    , used : List { name : String, type_ : String }\n    }\n\n\ntype alias DeclaredVariable =\n    { name : String\n    , type_ : Maybe String\n    }\n\n\ntype VarIssue\n    = Unused { name : String, possibly : List String }\n    | UnexpectedType\n        { name : String\n        , found : Maybe String\n        , expected : String\n        }\n    | Undeclared { name : String, possibly : List String }\n\n\ntype alias SuggestedVariable =\n    { name : String\n    , type_ : String\n    }\n\n\n\n{- Error rendering -}\n\n\n{-| An indented block with a newline above and below\n-}\nblock : List String -> String\nblock lines =\n    \"\\n    \" ++ String.join \"\\n    \" lines ++ \"\\n\"\n\n\n\n{-\n   If more colors are wanted, this is a good reference:\n   https://github.com/chalk/chalk/blob/main/source/vendor/ansi-styles/index.js\n-}\n\n\ncyan : String -> String\ncyan str =\n    color 36 39 str\n\n\nyellow : String -> String\nyellow str =\n    color 33 39 str\n\n\ngreen : String -> String\ngreen str =\n    color 32 39 str\n\n\nred : String -> String\nred str =\n    color 31 39 str\n\n\ngrey : String -> String\ngrey str =\n    color 90 39 str\n\n\ncolor : Int -> Int -> String -> String\ncolor openCode closeCode content =\n    let\n        delim code =\n            --\"\\\\u001B[\" ++ String.fromInt code ++ \"m\"\n            \"\\u{001B}[\" ++ String.fromInt code ++ \"m\"\n    in\n    delim openCode ++ content ++ delim closeCode\n\n\n\n{- -}\n\n\nerrorToString : Error -> String\nerrorToString (Error details) =\n    case details.error of\n        Todo msg ->\n            \"Todo: \" ++ msg\n\n        EnumUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this name:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        QueryUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this query:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        ObjectUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this object:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        InterfaceUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this interface:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        UnionUnknown name ->\n            String.join \"\\n\"\n                [ \"I don't recognize this union:\"\n                , block\n                    [ yellow name ]\n                ]\n\n        FieldUnknown field ->\n            String.join \"\\n\"\n                [ \"You're trying to access\"\n                , block\n                    [ cyan (field.object ++ \".\" ++ field.field)\n                    ]\n                , \"But I don't see a \" ++ cyan field.field ++ \" field on \" ++ cyan field.object\n                ]\n\n        UnknownArgs deets ->\n            case deets.allowedArgs of\n                [] ->\n                    String.join \"\\n\"\n                        [ yellow deets.field ++ \" has the following arguments:\"\n                        , block\n                            (List.map yellow deets.unknownArgs)\n                        , \"but the GQL schema says it can't have any!\"\n                        , \"Maybe the arguments are on the wrong field?\"\n                        ]\n\n                _ ->\n                    String.join \"\\n\"\n                        [ yellow deets.field ++ \" has these arguments, but I don't recognize them!\"\n                        , block\n                            (List.map yellow deets.unknownArgs)\n                        , \"Here are the arguments that this field can have:\"\n                        , block\n                            (List.map\n                                (\\opt ->\n                                    yellow opt.name ++ \": \" ++ cyan (GraphQL.Schema.typeToString opt.type_)\n                                )\n                                deets.allowedArgs\n                            )\n                        ]\n\n        EmptySelection deets ->\n            String.join \"\\n\"\n                [ \"This field isn't selecting anything\"\n                , block\n                    [ yellow deets.field ]\n                , \"But it is a \" ++ yellow deets.fieldType ++ \", which needs to select some fields.\"\n                , \"You can either remove it or select some of the following fields:\"\n                , block\n                    (List.map\n                        (\\opt ->\n                            yellow opt.field ++ \": \" ++ cyan opt.type_\n                        )\n                        deets.options\n                    )\n                ]\n\n        FieldAliasRequired deets ->\n            String.join \"\\n\"\n                [ \"I found two fields that have the same name:\"\n                , block\n                    [ yellow deets.fieldName ]\n                , \"Add an alias to one of them so there's no confusion!\"\n                ]\n\n        NonExhaustiveVariants deets ->\n            String.join \"\\n\"\n                [ \"There are still some variants that have not been covered for \" ++ cyan deets.unionName\n                , block\n                    (List.map yellow deets.leftOver)\n                , \"Add them to your query so that we know what data to select if they show up!\"\n                ]\n\n        MissingTypename deets ->\n            String.join \"\\n\"\n                [ cyan deets.tag ++ \" needs to select for \" ++ yellow \"__typename\"\n                , block\n                    [ \"... on \" ++ deets.tag ++ \" {\"\n                    , yellow \"    __typename\"\n                    , grey \"    # ... other fields\"\n                    , \"}\"\n                    ]\n                , \"If we don't have this, then we can't be totally sure what type is returned.\"\n                ]\n\n        EmptyUnionVariantSelection deets ->\n            String.join \"\\n\"\n                [ cyan deets.tag ++ \" needs to select at least one field.\"\n                , block\n                    [ \"... on \" ++ deets.tag ++ \" {\"\n                    , yellow \"    __typename\"\n                    , \"}\"\n                    ]\n                , \"If you don't need any more data, just add \" ++ yellow \"__typename\"\n                ]\n\n        IncorrectInlineInput deets ->\n            String.join \"\\n\"\n                [ cyan deets.arg ++ \" has the wrong type. I was expecting:\"\n                , block\n                    [ yellow (GraphQL.Schema.typeToString deets.schema)\n                    ]\n                , \"But found:\"\n                , block\n                    [ yellow (AST.valueToString deets.found)\n                    ]\n                ]\n\n        FragmentNotFound deets ->\n            let\n                fragmentsThatMatchThisObject =\n                    List.filter\n                        (\\frag ->\n                            deets.object == Can.nameToString frag.typeCondition\n                        )\n                        deets.options\n\n                fragmentsThatMatchThisName =\n                    List.filter\n                        (\\frag ->\n                            deets.found == Can.nameToString frag.name\n                        )\n                        deets.options\n            in\n            case fragmentsThatMatchThisObject of\n                [] ->\n                    case deets.options of\n                        [] ->\n                            String.join \"\\n\"\n                                [ \"I found a usage of a fragment named \" ++ cyan deets.found ++ \", but I don't see any fragments defined in this document!\"\n                                , \"You could add one by adding this if you want.\"\n                                , block\n                                    [ cyan \"fragment\" ++ \" on \" ++ yellow deets.object ++ \" {\"\n                                    , \"    # select some fields here!\"\n                                    , \"}\"\n                                    ]\n                                , \"Check out https://graphql.org/learn/queries/#fragments to learn more!\"\n                                ]\n\n                        _ ->\n                            let\n                                preamble =\n                                    [ cyan (\"...\" ++ deets.found) ++ \" looks a little weird to me.\"\n                                    , \"From where it is in the query, it should select from \" ++ yellow deets.object ++ \".\"\n                                    , \"But I wasn't able to find a fragment with this name that selects from \" ++ yellow deets.object ++ \".\"\n                                    ]\n\n                                specifics =\n                                    case fragmentsThatMatchThisName of\n                                        [] ->\n                                            [ \"Here are the fragments I know about.\"\n                                            , block\n                                                (List.map (yellow << fragmentName)\n                                                    deets.options\n                                                )\n                                            ]\n\n                                        [ single ] ->\n                                            [ \"I found this fragment, is it selecting from the wrong thing?\"\n                                            , block\n                                                (List.map (yellow << fragmentName)\n                                                    fragmentsThatMatchThisName\n                                                )\n                                            ]\n\n                                        multiple ->\n                                            [ \"Here are the fragments I know about.\"\n                                            , block\n                                                (List.map (yellow << fragmentName)\n                                                    deets.options\n                                                )\n                                            ]\n                            in\n                            String.join \"\\n\"\n                                (preamble ++ specifics)\n\n                [ single ] ->\n                    String.join \"\\n\"\n                        [ \"I don't recognize the fragment named \" ++ cyan deets.found ++ \".\"\n                        , \"Do you mean?\"\n                        , block\n                            (List.map (yellow << fragmentName)\n                                fragmentsThatMatchThisObject\n                            )\n                        ]\n\n                _ ->\n                    String.join \"\\n\"\n                        [ \"I don't recognize the fragment named \" ++ cyan deets.found ++ \".\"\n                        , \"Do you mean one of these?\"\n                        , block\n                            (List.map (yellow << fragmentName)\n                                fragmentsThatMatchThisObject\n                            )\n                        ]\n\n        FragmentTargetDoesntExist deets ->\n            String.join \"\\n\"\n                [ \"I found this fragment:\"\n                , block\n                    [ \"fragment \" ++ cyan deets.fragmentName ++ \" on \" ++ yellow deets.typeCondition\n                    ]\n                , \"But I wasn't able to find \" ++ yellow deets.typeCondition ++ \" in the schema.\"\n                , \"Is there a typo?\"\n                ]\n\n        FragmentDuplicateFound deets ->\n            if deets.firstTypeCondition == deets.secondTypeCondition && deets.firstFieldCount == deets.secondFieldCount then\n                String.join \"\\n\"\n                    [ \"I found two fragments with the name \" ++ yellow deets.firstName\n                    , \"Maybe they're just duplicates?\"\n                    , \"Fragments need to have globally unique names. Can you rename one?\"\n                    ]\n\n            else\n                String.join \"\\n\"\n                    [ \"I found two fragments with the name \" ++ yellow deets.firstName\n                    , block\n                        [ \"fragment \" ++ cyan deets.firstName ++ \" on \" ++ yellow deets.firstTypeCondition\n                        , \"fragment \" ++ cyan deets.secondName ++ \" on \" ++ yellow deets.secondTypeCondition\n                        ]\n                    , \"Fragments need to have globally unique names. Can you rename one?\"\n                    ]\n\n        FragmentSelectionNotAllowedInObjects deets ->\n            String.join \"\\n\"\n                [ \"I found a fragment named \" ++ yellow (AST.nameToString deets.fragment.tag)\n                , \"but it is inside the object named \" ++ cyan deets.objectName ++ \", which is neither an interface or a union.\"\n                , \"Is it in the right place?\"\n                ]\n\n        FragmentInlineTopLevel deets ->\n            String.join \"\\n\"\n                [ \"I found an inline fragment named \" ++ yellow (AST.nameToString deets.fragment.tag) ++ \" at the top level of the query.\"\n                , \"But this sort of fragment must be inside a union or an interface.\"\n                , \"Is it in the right place?\"\n                ]\n\n        VariableIssueSummary summary ->\n            case summary.declared of\n                [] ->\n                    String.join \"\\n\"\n                        [ \"I wasn't able to find any declared variables.\"\n                        , \"Here's what I think the variables should be:\"\n                        , block\n                            (List.map\n                                renderSuggestion\n                                (List.reverse summary.suggestions)\n                            )\n                        ]\n\n                _ ->\n                    String.join \"\\n\"\n                        [ \"I found the following variables:\"\n                        , block\n                            (List.map\n                                renderDeclared\n                                (List.reverse summary.declared)\n                            )\n                        , if List.length summary.issues == 1 then\n                            \"But I ran into an issue:\"\n\n                          else\n                            \"But I ran into a few issues:\"\n                        , block\n                            (List.concatMap\n                                renderIssue\n                                summary.issues\n                            )\n                        , \"Here's what I think the variables should be:\"\n                        , block\n                            (List.map\n                                renderSuggestion\n                                (List.reverse summary.suggestions)\n                            )\n                        ]\n\n        FragmentVariableIssue summary ->\n            String.join \"\\n\"\n                [ \"It looks like the \" ++ cyan summary.fragmentName ++ \" fragment uses the following variables:\"\n                , block\n                    (List.map\n                        renderVariable\n                        summary.used\n                    )\n                , \"But the only variables that are declared are\"\n                , block\n                    (List.map\n                        renderVariable\n                        summary.declared\n                    )\n                ]\n\n\nfragmentName : Can.Fragment -> String\nfragmentName frag =\n    Can.nameToString frag.name ++ \" on \" ++ Can.nameToString frag.typeCondition\n\n\nrenderVariable : { name : String, type_ : String } -> String\nrenderVariable var =\n    yellow var.name ++ cyan \": \" ++ yellow var.type_\n\n\nrenderDeclared : DeclaredVariable -> String\nrenderDeclared declared =\n    case declared.type_ of\n        Nothing ->\n            yellow (\"$\" ++ declared.name)\n\n        Just declaredType ->\n            yellow (\"$\" ++ declared.name) ++ grey \": \" ++ cyan declaredType\n\n\nrenderSuggestion : SuggestedVariable -> String\nrenderSuggestion sug =\n    yellow (\"$\" ++ sug.name) ++ grey \": \" ++ cyan sug.type_\n\n\nrenderIssue : VarIssue -> List String\nrenderIssue issue =\n    case issue of\n        Unused var ->\n            [ yellow (\"$\" ++ var.name) ++ \" is unused.\" ]\n\n        UnexpectedType var ->\n            case var.found of\n                Nothing ->\n                    [ yellow (\"$\" ++ var.name) ++ \" has no type declaration\" ]\n\n                Just foundType ->\n                    let\n                        variableName =\n                            \"$\" ++ var.name\n                    in\n                    [ yellow variableName\n                        ++ \" is declared as \"\n                        ++ cyan foundType\n                    , String.repeat (String.length variableName - 6) \" \"\n                        ++ \"but is expected to be \"\n                        ++ cyan var.expected\n                    ]\n\n        Undeclared var ->\n            [ yellow (\"$\" ++ var.name) ++ \" is undeclared (missing from the top).\" ]\n\n\ntype CanResult success\n    = CanError (List Error)\n    | CanSuccess Cache.Cache success\n\n\ntype alias References =\n    { schema : GraphQL.Schema.Schema\n    , fragments : Dict String Can.Fragment\n    , paths : Paths\n    }\n\n\nerr : List Error -> CanResult success\nerr =\n    CanError\n\n\nsuccess : Cache.Cache -> success -> CanResult success\nsuccess =\n    CanSuccess\n\n\nemptySuccess : CanResult (List a)\nemptySuccess =\n    CanSuccess Cache.empty []\n\n\ntype alias Paths =\n    { path : String\n    , gqlDir : List String\n    }\n\n\ncanonicalize : GraphQL.Schema.Schema -> Paths -> AST.Document -> Result (List Error) Can.Document\ncanonicalize schema paths doc =\n    let\n        fragmentResult =\n            List.foldl\n                (getFragments\n                    schema\n                )\n                (Ok Dict.empty)\n                doc.definitions\n    in\n    case fragmentResult of\n        Err fragErrorDetails ->\n            Err (List.map error fragErrorDetails)\n\n        Ok fragments ->\n            let\n                usedNames =\n                    UsedNames.init\n                        -- These are names that we know will be in the generated code\n                        [ \"Input\"\n                        , \"Response\"\n                        ]\n\n                ( _, canonicalizedFragments ) =\n                    List.foldl\n                        (canonicalizeFragment schema paths)\n                        ( usedNames, CanSuccess Cache.empty Dict.empty )\n                        (List.sortBy AST.fragmentCount\n                            (Dict.values fragments)\n                        )\n            in\n            case canonicalizedFragments of\n                CanSuccess fragmentCacne canonicalFrags ->\n                    let\n                        canonicalizedDefinitions =\n                            reduce\n                                (canonicalizeDefinition\n                                    { schema = schema\n                                    , fragments =\n                                        canonicalFrags\n                                    , paths = paths\n                                    }\n                                    usedNames\n                                )\n                                doc.definitions\n                                emptySuccess\n                    in\n                    case canonicalizedDefinitions of\n                        CanSuccess cache defs ->\n                            Ok\n                                { definitions = defs\n                                , fragments = Dict.values canonicalFrags\n                                }\n\n                        CanError errorMsg ->\n                            Err errorMsg\n\n                CanError errorMsg ->\n                    Err errorMsg\n\n\ngetFragments :\n    GraphQL.Schema.Schema\n    -> AST.Definition\n    -> Result (List ErrorDetails) (Dict String AST.FragmentDetails)\n    -> Result (List ErrorDetails) (Dict String AST.FragmentDetails)\ngetFragments schema def result =\n    case result of\n        Err errs ->\n            Err errs\n\n        Ok frags ->\n            case def of\n                AST.Operation op ->\n                    result\n\n                AST.Fragment frag ->\n                    let\n                        name =\n                            AST.nameToString frag.name\n                    in\n                    case Dict.get name frags of\n                        Nothing ->\n                            frags\n                                |> Dict.insert\n                                    (AST.nameToString frag.name)\n                                    frag\n                                |> Ok\n\n                        Just found ->\n                            Err\n                                [ FragmentDuplicateFound\n                                    { firstName = AST.nameToString frag.name\n                                    , firstTypeCondition = AST.nameToString frag.typeCondition\n                                    , firstFieldCount = List.length frag.selection\n                                    , secondName = AST.nameToString found.name\n                                    , secondTypeCondition = AST.nameToString found.typeCondition\n                                    , secondFieldCount = List.length found.selection\n                                    }\n                                ]\n\n\nreduce :\n    (item -> Maybe (CanResult result))\n    -> List item\n    -> CanResult (List result)\n    -> CanResult (List result)\nreduce isValid items res =\n    case items of\n        [] ->\n            res\n\n        top :: remain ->\n            case isValid top of\n                Nothing ->\n                    reduce isValid remain res\n\n                Just (CanSuccess cache valid) ->\n                    case res of\n                        CanSuccess existingCache existing ->\n                            reduce isValid\n                                remain\n                                (CanSuccess (Cache.merge cache existingCache) (valid :: existing))\n\n                        CanError _ ->\n                            res\n\n                Just (CanError errorMessage) ->\n                    let\n                        newResult =\n                            case res of\n                                CanSuccess _ _ ->\n                                    CanError errorMessage\n\n                                CanError existingErrors ->\n                                    CanError (errorMessage ++ existingErrors)\n                    in\n                    reduce isValid remain newResult\n\n\nconvertName : AST.Name -> Can.Name\nconvertName (AST.Name str) =\n    Can.Name str\n\n\ncanonicalizeDefinition :\n    References\n    -> UsedNames.UsedNames\n    -> AST.Definition\n    -> Maybe (CanResult Can.Definition)\ncanonicalizeDefinition refs usedNames def =\n    case def of\n        AST.Fragment details ->\n            Nothing\n\n        AST.Operation details ->\n            let\n                globalOperationName =\n                    Maybe.map convertName details.name\n\n                operationType =\n                    case details.operationType of\n                        AST.Query ->\n                            Can.Query\n\n                        AST.Mutation ->\n                            Can.Mutation\n\n                initialNameCache =\n                    usedNames\n                        |> UsedNames.getGlobalName\n                            (globalOperationName\n                                |> Maybe.map Can.nameToString\n                                |> Maybe.withDefault (opTypeName operationType)\n                            )\n\n                fieldResult =\n                    List.foldl\n                        (\\field ( used, result ) ->\n                            case result of\n                                CanSuccess oldCache oldItems ->\n                                    let\n                                        ( newUsed, newResult ) =\n                                            canonicalizeOperation\n                                                refs\n                                                details.operationType\n                                                used\n                                                field\n                                    in\n                                    ( newUsed\n                                    , case newResult of\n                                        CanError errorMessage ->\n                                            CanError errorMessage\n\n                                        CanSuccess newCache validItem ->\n                                            CanSuccess\n                                                (Cache.merge oldCache newCache)\n                                                (validItem :: oldItems)\n                                    )\n\n                                CanError _ ->\n                                    ( used, result )\n                        )\n                        ( initialNameCache.used\n                        , emptySuccess\n                        )\n                        details.fields\n            in\n            Just <|\n                case Tuple.second fieldResult of\n                    CanSuccess cache fields ->\n                        let\n                            variableSummary =\n                                List.foldl\n                                    verifyVariables\n                                    { declared = []\n                                    , valid = []\n                                    , issues = []\n                                    , suggestions = []\n                                    }\n                                    (mergeVars cache.varTypes details.variableDefinitions)\n\n                            fragmentVariableIssues =\n                                List.filterMap\n                                    (fragmentVariableErrors details.variableDefinitions)\n                                    (List.map .fragment cache.fragmentsUsed)\n                        in\n                        if not (List.isEmpty variableSummary.issues) then\n                            CanError\n                                [ error\n                                    (VariableIssueSummary variableSummary)\n                                ]\n\n                        else if not (List.isEmpty fragmentVariableIssues) then\n                            CanError\n                                (List.map\n                                    (error << FragmentVariableIssue)\n                                    fragmentVariableIssues\n                                )\n\n                        else\n                            CanSuccess cache <|\n                                Can.Operation\n                                    { operationType =\n                                        operationType\n                                    , name = globalOperationName\n                                    , variableDefinitions =\n                                        variableSummary.valid\n                                    , directives =\n                                        List.map convertDirective details.directives\n                                    , fields = fields\n                                    , fragmentsUsed = cache.fragmentsUsed\n                                    }\n\n                    CanError errorMsg ->\n                        CanError errorMsg\n\n\nfragmentVariableErrors : List AST.VariableDefinition -> Can.Fragment -> Maybe FragmentVariableSummary\nfragmentVariableErrors varDefs frag =\n    let\n        varSummary =\n            { fragmentName = Can.nameToString frag.name\n            , declared =\n                List.map\n                    (\\def ->\n                        { name = AST.nameToString def.variable.name\n                        , type_ = AST.typeToGqlString def.type_\n                        }\n                    )\n                    varDefs\n            , used =\n                List.map\n                    (\\( name, varType ) ->\n                        { name = name\n                        , type_ = GraphQL.Schema.typeToString varType\n                        }\n                    )\n                    frag.usedVariables\n            }\n\n        variableIssue ( name, varType ) existingIssue =\n            case existingIssue of\n                Just _ ->\n                    existingIssue\n\n                _ ->\n                    case List.head (List.filter (\\def -> AST.nameToString def.variable.name == name) varDefs) of\n                        Nothing ->\n                            Just varSummary\n\n                        Just found ->\n                            if String.toLower (AST.typeToGqlString found.type_) == String.toLower (GraphQL.Schema.typeToString varType) then\n                                Nothing\n\n                            else\n                                Just varSummary\n    in\n    List.foldl variableIssue Nothing frag.usedVariables\n\n\nopTypeName : Can.OperationType -> String\nopTypeName op =\n    case op of\n        Can.Query ->\n            \"Query\"\n\n        Can.Mutation ->\n            \"Mutation\"\n\n\n{-| The AST.Type is the type declared at the top of the document.\n\nThe Schema.Type is what is in the schema.\n\n    variableDefinition is the AST representation of the variable declaration at the top.\n\n-}\ndoTypesMatch : GraphQL.Schema.Type -> AST.Type -> Bool\ndoTypesMatch schemaType variableDefinition =\n    case variableDefinition of\n        AST.Type_ astName ->\n            case schemaType of\n                GraphQL.Schema.Scalar schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.InputObject schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Object schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Enum schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Union schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.Interface schemaName ->\n                    AST.nameToString astName\n                        == schemaName\n\n                GraphQL.Schema.List_ innerSchema ->\n                    False\n\n                GraphQL.Schema.Nullable innerSchema ->\n                    -- the query can mark something as required even if it's optional in the schema\n                    doTypesMatch innerSchema variableDefinition\n\n        AST.Nullable innerAST ->\n            case schemaType of\n                GraphQL.Schema.Nullable innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                otherwise ->\n                    False\n\n        AST.List_ innerAST ->\n            case schemaType of\n                GraphQL.Schema.List_ innerSchema ->\n                    doTypesMatch innerSchema innerAST\n\n                GraphQL.Schema.Nullable innerSchema ->\n                    -- the query can mark something as required even if it's optional in the schema\n                    doTypesMatch innerSchema variableDefinition\n\n                _ ->\n                    False\n\n\nverifyVariables :\n    { name : String\n    , definition : Maybe AST.VariableDefinition\n    , inOperation : Maybe GraphQL.Schema.Type\n    }\n    -> VariableSummary\n    -> VariableSummary\nverifyVariables item summary =\n    case ( item.definition, item.inOperation ) of\n        ( Just def, Just inOp ) ->\n            -- check to make sure the variables are unifiable\n            let\n                valid =\n                    { variable = { name = convertName def.variable.name }\n                    , type_ = def.type_\n                    , defaultValue = def.defaultValue\n                    , schemaType = inOp\n                    }\n\n                typeString =\n                    GraphQL.Schema.typeToString inOp\n\n                declared =\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        Just\n                            (AST.typeToGqlString def.type_)\n                    }\n\n                suggestion =\n                    { name = AST.nameToString def.variable.name\n                    , type_ = typeString\n                    }\n\n                typesMatch =\n                    doTypesMatch inOp def.type_\n            in\n            { declared = declared :: summary.declared\n            , valid = valid :: summary.valid\n            , issues =\n                if typesMatch then\n                    summary.issues\n\n                else\n                    UnexpectedType\n                        { name = item.name\n                        , found = Just (AST.typeToGqlString def.type_)\n                        , expected = typeString\n                        }\n                        :: summary.issues\n            , suggestions =\n                if typesMatch then\n                    -- we do this so that when we print an error message\n                    -- If the user has specified that this is a required value\n                    -- but the schema says it's optional\n                    -- we maintain the required-ness\n                    { name = AST.nameToString def.variable.name\n                    , type_ =\n                        AST.typeToGqlString def.type_\n                    }\n                        :: summary.suggestions\n\n                else\n                    suggestion :: summary.suggestions\n            }\n\n        ( Just def, Nothing ) ->\n            { declared =\n                { name = AST.nameToString def.variable.name\n                , type_ = Nothing\n                }\n                    :: summary.declared\n            , valid = summary.valid\n            , issues =\n                Unused\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions =\n                summary.suggestions\n            }\n\n        ( Nothing, Just inOp ) ->\n            let\n                suggestion =\n                    { name = item.name\n                    , type_ = GraphQL.Schema.typeToString inOp\n                    }\n            in\n            { declared = summary.declared\n            , valid = summary.valid\n            , issues =\n                Undeclared\n                    { name = item.name\n                    , possibly = []\n                    }\n                    :: summary.issues\n            , suggestions = suggestion :: summary.suggestions\n            }\n\n        ( Nothing, Nothing ) ->\n            summary\n\n\nmergeVars :\n    List ( String, GraphQL.Schema.Type )\n    -> List AST.VariableDefinition\n    ->\n        List\n            { name : String\n            , definition : Maybe AST.VariableDefinition\n            , inOperation : Maybe GraphQL.Schema.Type\n            }\nmergeVars varTypes variableDefinitions =\n    let\n        allNames =\n            List.foldl\n                (\\varName found ->\n                    if List.member varName found then\n                        found\n\n                    else\n                        varName :: found\n                )\n                []\n                (List.map (.variable >> .name >> AST.nameToString) variableDefinitions\n                    ++ List.map Tuple.first varTypes\n                )\n                |> List.reverse\n    in\n    List.map\n        (\\name ->\n            { name = name\n            , definition =\n                List.foldl\n                    (\\def found ->\n                        case found of\n                            Nothing ->\n                                if AST.nameToString def.variable.name == name then\n                                    Just def\n\n                                else\n                                    found\n\n                            _ ->\n                                found\n                    )\n                    Nothing\n                    variableDefinitions\n            , inOperation =\n                find name varTypes\n            }\n        )\n        allNames\n\n\nfind : String -> List ( String, a ) -> Maybe a\nfind str items =\n    case items of\n        [] ->\n            Nothing\n\n        ( key, val ) :: remain ->\n            if str == key then\n                Just val\n\n            else\n                find str remain\n\n\ncanonicalizeOperation :\n    References\n    -> AST.OperationType\n    -> UsedNames.UsedNames\n    -> AST.Selection\n    -> ( UsedNames.UsedNames, CanResult Can.Field )\ncanonicalizeOperation refs op used selection =\n    case selection of\n        AST.Field field ->\n            let\n                desiredName =\n                    field.alias_\n                        |> Maybe.withDefault field.name\n                        |> convertName\n                        |> Can.nameToString\n\n                matched =\n                    case op of\n                        AST.Query ->\n                            Dict.get (AST.nameToString field.name) refs.schema.queries\n\n                        AST.Mutation ->\n                            Dict.get (AST.nameToString field.name) refs.schema.mutations\n            in\n            case matched of\n                Nothing ->\n                    ( used, err [ error (QueryUnknown (AST.nameToString field.name)) ] )\n\n                Just query ->\n                    canonicalizeFieldType refs\n                        field\n                        used\n                        query\n                        |> Tuple.mapFirst UsedNames.dropLevel\n\n        AST.FragmentSpreadSelection frag ->\n            ( used, err [ todo \"Top level Fragments aren't suported yet!\" ] )\n\n        AST.InlineFragmentSelection inline ->\n            -- This is when we're selecting a union fragment\n            ( used, err [ error (FragmentInlineTopLevel { fragment = inline }) ] )\n\n\ntype InputValidation\n    = Valid (List ( String, GraphQL.Schema.Type ))\n    | InputError ErrorDetails\n    | Mismatch\n\n\nvalidateInput :\n    References\n    -> GraphQL.Schema.Type\n    -> String\n    -> AST.Value\n    -> InputValidation\nvalidateInput refs schemaType fieldName astValue =\n    case astValue of\n        AST.Var var ->\n            let\n                varname =\n                    AST.nameToString var.name\n            in\n            Valid [ ( varname, schemaType ) ]\n\n        AST.Object keyValues ->\n            case schemaType of\n                GraphQL.Schema.InputObject inputObjectName ->\n                    case Dict.get inputObjectName refs.schema.inputObjects of\n                        Nothing ->\n                            Mismatch\n\n                        Just inputObject ->\n                            validateObject refs fieldName keyValues inputObject\n\n                GraphQL.Schema.Nullable (GraphQL.Schema.InputObject inputObjectName) ->\n                    case Dict.get inputObjectName refs.schema.inputObjects of\n                        Nothing ->\n                            Mismatch\n\n                        Just inputObject ->\n                            validateObject refs fieldName keyValues inputObject\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Str str ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Int\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar \"Boolean\" ->\n                    Mismatch\n\n                GraphQL.Schema.Scalar _ ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Integer int ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Int\" ->\n                    Valid []\n\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Decimal float ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Float\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Boolean bool ->\n            case schemaType of\n                GraphQL.Schema.Scalar \"Boolean\" ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.Null ->\n            case schemaType of\n                GraphQL.Schema.Nullable _ ->\n                    Valid []\n\n                _ ->\n                    Mismatch\n\n        AST.Enum enumName ->\n            case schemaType of\n                GraphQL.Schema.Enum _ ->\n                    Valid []\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                GraphQL.Schema.List_ inner ->\n                    -- A single literal can be coerced into a list\n                    -- https://spec.graphql.org/June2018/#sec-Type-System.List\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n        AST.ListValue list ->\n            case schemaType of\n                GraphQL.Schema.List_ innerList ->\n                    List.foldl\n                        (\\item current ->\n                            case current of\n                                Valid validArgs ->\n                                    case validateInput refs innerList fieldName item of\n                                        Valid newArgs ->\n                                            Valid (newArgs ++ validArgs)\n\n                                        validationError ->\n                                            validationError\n\n                                _ ->\n                                    current\n                        )\n                        (Valid [])\n                        list\n\n                GraphQL.Schema.Nullable inner ->\n                    validateInput refs inner fieldName astValue\n\n                _ ->\n                    Mismatch\n\n\nvalidateObject refs fieldName keyValues inputObject =\n    List.foldl\n        (\\( keyName, value ) current ->\n            let\n                key =\n                    AST.nameToString keyName\n            in\n            case current of\n                Valid argValues ->\n                    case List.head (List.filter (\\a -> a.name == key) inputObject.fields) of\n                        Nothing ->\n                            Mismatch\n\n                        Just field ->\n                            case validateInput refs field.type_ fieldName value of\n                                Valid fieldArgs ->\n                                    Valid (argValues ++ fieldArgs)\n\n                                validationError ->\n                                    validationError\n\n                _ ->\n                    current\n        )\n        (Valid [])\n        keyValues\n\n\n{-| -}\ngetFragmentOverrideName : List AST.Selection -> String -> String\ngetFragmentOverrideName selectedFields name =\n    case selectedFields of\n        [ AST.FragmentSpreadSelection fragment ] ->\n            AST.nameToString fragment.name\n\n        _ ->\n            name\n\n\nselectsSingleFragment :\n    References\n    -> List AST.Selection\n    ->\n        Maybe\n            { importFrom : List String\n            , name : String\n            }\nselectsSingleFragment refs fields =\n    case fields of\n        [ AST.FragmentSpreadSelection fragment ] ->\n            let\n                fragName =\n                    Utils.String.formatTypename (AST.nameToString fragment.name)\n\n                paths =\n                    Generate.Path.fragment\n                        { name = fragName\n                        , path = refs.paths.path\n                        , gqlDir = refs.paths.gqlDir\n                        }\n            in\n            Just\n                { importFrom = paths.modulePath\n                , name = fragName\n                }\n\n        _ ->\n            Nothing\n\n\n{-| -}\ngetGlobalNameWithFragmentAlias :\n    List AST.Selection\n    -> String\n    -> UsedNames.UsedNames\n    ->\n        { globalName : String\n        , used : UsedNames.UsedNames\n        }\ngetGlobalNameWithFragmentAlias selection name usedNames =\n    UsedNames.getGlobalName name\n        usedNames\n\n\ncanonicalizeFragment :\n    GraphQL.Schema.Schema\n    -> Paths\n    -> AST.FragmentDetails\n    -> ( UsedNames.UsedNames, CanResult (Dict String Can.Fragment) )\n    -> ( UsedNames.UsedNames, CanResult (Dict String Can.Fragment) )\ncanonicalizeFragment schema paths frag ( usedNames, currentResult ) =\n    case currentResult of\n        CanError errMsg ->\n            ( usedNames, CanError errMsg )\n\n        CanSuccess cache existingFrags ->\n            let\n                fragName =\n                    AST.nameToString frag.name\n\n                fragPaths =\n                    Generate.Path.fragment\n                        { name = fragName\n                        , path = paths.path\n                        , gqlDir = paths.gqlDir\n                        }\n\n                typeCondition =\n                    AST.nameToString frag.typeCondition\n            in\n            case Dict.get typeCondition schema.objects of\n                Just obj ->\n                    let\n                        selectionResult =\n                            List.foldl\n                                (canonicalizeField\n                                    { schema = schema\n                                    , fragments = existingFrags\n                                    , paths = paths\n                                    }\n                                    obj\n                                )\n                                { result = CanSuccess Cache.empty []\n                                , fieldNames =\n                                    usedNames\n                                        |> UsedNames.addLevel\n                                            { name = AST.nameToString frag.name\n                                            , isAlias = False\n                                            }\n                                }\n                                frag.selection\n                    in\n                    ( selectionResult.fieldNames\n                    , case selectionResult.result of\n                        CanSuccess fragmentSpecificCache selection ->\n                            CanSuccess fragmentSpecificCache\n                                (existingFrags\n                                    |> Dict.insert fragName\n                                        { name = convertName frag.name\n                                        , importFrom = fragPaths.modulePath\n                                        , typeCondition = convertName frag.typeCondition\n                                        , usedVariables = fragmentSpecificCache.varTypes\n                                        , fragmentsUsed =\n                                            List.map (.fragment >> .name) fragmentSpecificCache.fragmentsUsed\n                                        , directives = List.map convertDirective frag.directives\n                                        , selection =\n                                            Can.FragmentObject\n                                                { selection = selection }\n                                        }\n                                )\n\n                        CanError errorMsg ->\n                            CanError errorMsg\n                    )\n\n                Nothing ->\n                    case Dict.get typeCondition schema.interfaces of\n                        Just interface ->\n                            let\n                                variants =\n                                    List.foldl getInterfaceNames [] interface.implementedBy\n\n                                ( finalUsedNames, canVarSelectionResult ) =\n                                    canonicalizeVariantSelection\n                                        { schema = schema\n                                        , fragments = existingFrags\n                                        , paths = paths\n                                        }\n                                        (usedNames\n                                            |> UsedNames.addLevel\n                                                { name = AST.nameToString frag.name\n                                                , isAlias = False\n                                                }\n                                        )\n                                        { name = interface.name\n                                        , description = interface.description\n                                        , fields = interface.fields\n                                        }\n                                        frag.selection\n                                        variants\n                            in\n                            ( finalUsedNames\n                            , case canVarSelectionResult of\n                                CanSuccess fragmentSpecificCache selection ->\n                                    CanSuccess fragmentSpecificCache\n                                        (existingFrags\n                                            |> Dict.insert (AST.nameToString frag.name)\n                                                { name = convertName frag.name\n                                                , importFrom = fragPaths.modulePath\n                                                , typeCondition = convertName frag.typeCondition\n                                                , usedVariables = fragmentSpecificCache.varTypes\n                                                , fragmentsUsed = List.map (.fragment >> .name) fragmentSpecificCache.fragmentsUsed\n                                                , directives = List.map convertDirective frag.directives\n                                                , selection =\n                                                    Can.FragmentInterface selection\n                                                }\n                                        )\n\n                                CanError errorMsg ->\n                                    CanError errorMsg\n                            )\n\n                        Nothing ->\n                            case Dict.get typeCondition schema.unions of\n                                Just union ->\n                                    let\n                                        variants =\n                                            Maybe.withDefault [] <| extractUnionTags union.variants []\n\n                                        ( finalUsedNames, canVarSelectionResult ) =\n                                            canonicalizeVariantSelection\n                                                { schema = schema\n                                                , fragments = existingFrags\n                                                , paths = paths\n                                                }\n                                                (usedNames\n                                                    |> UsedNames.addLevel\n                                                        { name = AST.nameToString frag.name\n                                                        , isAlias = False\n                                                        }\n                                                )\n                                                { name = union.name\n                                                , description = union.description\n                                                , fields = []\n                                                }\n                                                frag.selection\n                                                variants\n                                    in\n                                    ( finalUsedNames\n                                    , case canVarSelectionResult of\n                                        CanSuccess fragmentSpecificCache selection ->\n                                            CanSuccess fragmentSpecificCache\n                                                (existingFrags\n                                                    |> Dict.insert (AST.nameToString frag.name)\n                                                        { name = convertName frag.name\n                                                        , importFrom = fragPaths.modulePath\n                                                        , typeCondition = convertName frag.typeCondition\n                                                        , usedVariables = fragmentSpecificCache.varTypes\n                                                        , fragmentsUsed =\n                                                            List.map (.fragment >> .name) fragmentSpecificCache.fragmentsUsed\n                                                        , directives = List.map convertDirective frag.directives\n                                                        , selection =\n                                                            Can.FragmentUnion selection\n                                                        }\n                                                )\n\n                                        CanError errorMsg ->\n                                            CanError errorMsg\n                                    )\n\n                                Nothing ->\n                                    ( usedNames\n                                    , CanError\n                                        [ error <|\n                                            FragmentTargetDoesntExist\n                                                { fragmentName = AST.nameToString frag.name\n                                                , typeCondition = AST.nameToString frag.typeCondition\n                                                }\n                                        ]\n                                    )\n\n\ncanonicalizeVariantSelection :\n    References\n    -> UsedNames.UsedNames\n    ->\n        { description : Maybe String\n        , fields :\n            List GraphQL.Schema.Field\n        , name : String\n        }\n    -> List AST.Selection\n    -> List String\n    ->\n        ( UsedNames.UsedNames\n        , CanResult\n            { remainingTags : List { globalAlias : Can.Name, tag : Can.Name }\n            , selection : List Can.Field\n            , variants : List Can.VariantCase\n            }\n        )\ncanonicalizeVariantSelection refs usedNames unionOrInterface selection variants =\n    let\n        selectsForTypename =\n            List.any\n                (\\sel ->\n                    case sel of\n                        AST.Field firstField ->\n                            case AST.nameToString firstField.name of\n                                \"__typename\" ->\n                                    True\n\n                                _ ->\n                                    False\n\n                        _ ->\n                            False\n                )\n                selection\n\n        selectionResult =\n            List.foldl\n                (canonicalizeFieldWithVariants refs\n                    unionOrInterface\n                )\n                { result = emptySuccess\n                , capturedVariants = []\n                , fieldNames =\n                    usedNames\n                , variants = variants\n                , typenameAlreadySelected = selectsForTypename\n                }\n                selection\n\n        ( remainingUsedNames, remaining ) =\n            List.foldl\n                gatherRemaining\n                ( selectionResult.fieldNames\n                , []\n                )\n                selectionResult.variants\n    in\n    case selectionResult.result of\n        CanSuccess cache canSelection ->\n            ( remainingUsedNames\n                |> UsedNames.dropLevel\n            , CanSuccess cache\n                { selection = canSelection\n                , variants = selectionResult.capturedVariants\n                , remainingTags =\n                    List.reverse remaining\n                }\n            )\n\n        CanError errorMsg ->\n            ( remainingUsedNames, CanError errorMsg )\n\n\n{-| -}\ncanonicalizeField :\n    References\n    ->\n        { obj\n            | name : String\n            , description : Maybe String\n            , fields : List GraphQL.Schema.Field\n        }\n    -> AST.Selection\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames.UsedNames\n        }\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames.UsedNames\n        }\ncanonicalizeField refs object selection found =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n\n                aliased =\n                    AST.getAliasedName field\n            in\n            if fieldName == \"__typename\" then\n                { result =\n                    addToResult Cache.empty\n                        (Can.Field\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , globalAlias =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                            , selectsOnlyFragment = Nothing\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , wrapper = GraphQL.Schema.UnwrappedValue\n                            , selection =\n                                Can.FieldScalar (GraphQL.Schema.Scalar \"typename\")\n                            }\n                        )\n                        found.result\n                , fieldNames = found.fieldNames\n                }\n\n            else\n                let\n                    matchedField =\n                        object.fields\n                            |> List.filter (\\fld -> fld.name == fieldName)\n                            |> List.head\n                in\n                case matchedField of\n                    Just matched ->\n                        let\n                            ( newNames, cannedSelection ) =\n                                canonicalizeFieldType refs\n                                    field\n                                    found.fieldNames\n                                    matched\n\n                            siblingID =\n                                { aliasedName = aliased\n                                , scalar =\n                                    if GraphQL.Schema.isScalar matched.type_ then\n                                        Just (GraphQL.Schema.typeToString matched.type_)\n\n                                    else\n                                        Nothing\n                                }\n                        in\n                        if UsedNames.siblingCollision siblingID found.fieldNames then\n                            -- There has been a collision, abort!\n                            { result =\n                                err\n                                    [ error\n                                        (FieldAliasRequired\n                                            { fieldName = aliased\n                                            }\n                                        )\n                                    ]\n                            , fieldNames = found.fieldNames\n                            }\n\n                        else\n                            { result =\n                                case cannedSelection of\n                                    CanSuccess cache sel ->\n                                        addToResult cache sel found.result\n\n                                    CanError errMsg ->\n                                        CanError errMsg\n                            , fieldNames =\n                                newNames\n                                    |> UsedNames.saveSibling siblingID\n                            }\n\n                    Nothing ->\n                        { result =\n                            err\n                                [ error\n                                    (FieldUnknown\n                                        { object = object.name\n                                        , field = fieldName\n                                        }\n                                    )\n                                ]\n                        , fieldNames = found.fieldNames\n                        }\n\n        AST.FragmentSpreadSelection frag ->\n            let\n                fragName =\n                    AST.nameToString frag.name\n            in\n            case Dict.get fragName refs.fragments of\n                Nothing ->\n                    { result =\n                        err\n                            [ error <|\n                                FragmentNotFound\n                                    { found = fragName\n                                    , object = object.name\n                                    , options =\n                                        Dict.values refs.fragments\n                                    }\n                            ]\n                    , fieldNames = found.fieldNames\n                    }\n\n                Just foundFrag ->\n                    if Can.nameToString foundFrag.typeCondition == object.name then\n                        { result =\n                            found.result\n                                |> addToResult\n                                    (Cache.empty\n                                        |> Cache.addFragment\n                                            { fragment = foundFrag\n                                            , alongsideOtherFields = False\n                                            }\n                                    )\n                                    (Can.Frag\n                                        { fragment = foundFrag\n                                        , directives =\n                                            frag.directives\n                                                |> List.map\n                                                    convertDirective\n                                        }\n                                    )\n                        , fieldNames =\n                            found.fieldNames\n                        }\n\n                    else\n                        { result =\n                            err\n                                [ error <|\n                                    FragmentNotFound\n                                        { found = fragName\n                                        , object = object.name\n                                        , options =\n                                            Dict.values refs.fragments\n                                        }\n                                ]\n                        , fieldNames = found.fieldNames\n                        }\n\n        AST.InlineFragmentSelection inline ->\n            { result =\n                err\n                    [ error\n                        (FragmentSelectionNotAllowedInObjects\n                            { fragment = inline\n                            , objectName = object.name\n                            }\n                        )\n                    ]\n            , fieldNames = found.fieldNames\n            }\n\n\nconvertDirective dir =\n    { name = convertName dir.name\n    , arguments =\n        dir.arguments\n    }\n\n\ncanonicalizeFieldType :\n    References\n    -> AST.FieldDetails\n    -> UsedNames.UsedNames\n    -> GraphQL.Schema.Field\n    ->\n        ( UsedNames.UsedNames\n        , CanResult Can.Field\n        )\ncanonicalizeFieldType refs field usedNames schemaField =\n    canonicalizeFieldTypeHelper refs field schemaField.type_ usedNames Cache.empty schemaField\n\n\ncanonicalizeArguments :\n    References\n    -> List GraphQL.Schema.Argument\n    -> List AST.Argument\n    ->\n        { valid : List ( String, GraphQL.Schema.Type )\n        , unknown : List String\n        , errs : List Error\n        }\ncanonicalizeArguments refs schemaArguments arguments =\n    List.foldl\n        (\\arg found ->\n            let\n                fieldname =\n                    AST.nameToString arg.name\n            in\n            case List.head (List.filter (\\a -> a.name == fieldname) schemaArguments) of\n                Nothing ->\n                    { found\n                        | unknown =\n                            fieldname :: found.unknown\n                    }\n\n                Just schemaVar ->\n                    case validateInput refs schemaVar.type_ fieldname arg.value of\n                        Valid vars ->\n                            { found\n                                | valid =\n                                    vars ++ found.valid\n                            }\n\n                        InputError errorDetails ->\n                            { found\n                                | errs =\n                                    error errorDetails :: found.errs\n                            }\n\n                        Mismatch ->\n                            { found\n                                | errs =\n                                    error\n                                        (IncorrectInlineInput\n                                            { schema = schemaVar.type_\n                                            , arg = fieldname\n                                            , found = arg.value\n                                            }\n                                        )\n                                        :: found.errs\n                            }\n        )\n        { valid = []\n        , unknown = []\n        , errs = []\n        }\n        arguments\n\n\n{-|\n\n    For `field`, we are matching it up with types from `schema`\n\n-}\ncanonicalizeFieldTypeHelper :\n    References\n    -> AST.FieldDetails\n    -> GraphQL.Schema.Type\n    -> UsedNames.UsedNames\n    -> Cache.Cache\n    -> GraphQL.Schema.Field\n    -> ( UsedNames.UsedNames, CanResult Can.Field )\ncanonicalizeFieldTypeHelper refs field type_ usedNames initialVarCache schemaField =\n    let\n        argValidation =\n            canonicalizeArguments refs schemaField.arguments field.arguments\n    in\n    if not (List.isEmpty argValidation.unknown) then\n        ( usedNames\n        , CanError\n            [ error <|\n                UnknownArgs\n                    { field = AST.nameToString field.name\n                    , unknownArgs = argValidation.unknown\n                    , allowedArgs =\n                        schemaField.arguments\n                    }\n            ]\n        )\n\n    else if not (List.isEmpty argValidation.errs) then\n        ( usedNames, CanError argValidation.errs )\n\n    else\n        let\n            vars =\n                List.reverse argValidation.valid\n\n            newCache =\n                initialVarCache |> Cache.addVars vars\n        in\n        case type_ of\n            GraphQL.Schema.Scalar name ->\n                ( usedNames\n                , success newCache\n                    (Can.Field\n                        { alias_ = Maybe.map convertName field.alias_\n                        , name = convertName field.name\n                        , selectsOnlyFragment = Nothing\n                        , globalAlias =\n                            field.alias_\n                                |> Maybe.withDefault field.name\n                                |> convertName\n                        , arguments = field.arguments\n                        , directives = List.map convertDirective field.directives\n                        , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                        , selection =\n                            Can.FieldScalar (GraphQL.Schema.getInner schemaField.type_)\n                        }\n                    )\n                )\n\n            GraphQL.Schema.InputObject name ->\n                ( usedNames\n                , err [ todo \"Invalid schema!  Weird InputObject\" ]\n                )\n\n            GraphQL.Schema.Object name ->\n                case Dict.get name refs.schema.objects of\n                    Nothing ->\n                        ( usedNames, err [ error (ObjectUnknown name) ] )\n\n                    Just obj ->\n                        canonicalizeObject refs\n                            field\n                            usedNames\n                            schemaField\n                            newCache\n                            obj\n\n            GraphQL.Schema.Enum name ->\n                case Dict.get name refs.schema.enums of\n                    Nothing ->\n                        ( usedNames, err [ error (EnumUnknown name) ] )\n\n                    Just enum ->\n                        ( usedNames\n                        , CanSuccess newCache\n                            (Can.Field\n                                { alias_ = Maybe.map convertName field.alias_\n                                , name = convertName field.name\n                                , globalAlias =\n                                    field.alias_\n                                        |> Maybe.withDefault field.name\n                                        |> convertName\n                                , selectsOnlyFragment = Nothing\n                                , arguments = field.arguments\n                                , directives = List.map convertDirective field.directives\n                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                , selection =\n                                    Can.FieldEnum\n                                        { enumName = enum.name\n                                        , values = enum.values\n                                        }\n                                }\n                            )\n                        )\n\n            GraphQL.Schema.Union name ->\n                case Dict.get name refs.schema.unions of\n                    Nothing ->\n                        ( usedNames, err [ error (UnionUnknown name) ] )\n\n                    Just union ->\n                        case extractUnionTags union.variants [] of\n                            Nothing ->\n                                ( usedNames, err [ todo \"Things in a union are not objects!\" ] )\n\n                            Just variants ->\n                                let\n                                    aliasedName =\n                                        field.alias_\n                                            |> Maybe.withDefault field.name\n                                            |> convertName\n                                            |> Can.nameToString\n\n                                    global =\n                                        getGlobalNameWithFragmentAlias\n                                            field.selection\n                                            aliasedName\n                                            usedNames\n\n                                    ( finalUsedNames, canVarSelectionResult ) =\n                                        canonicalizeVariantSelection refs\n                                            (global.used\n                                                |> UsedNames.addLevel (UsedNames.levelFromField field)\n                                            )\n                                            { name = union.name\n                                            , description = union.description\n\n                                            -- Note, unions dont have any fields themselves, unlike interfaces\n                                            , fields = []\n                                            }\n                                            field.selection\n                                            variants\n                                in\n                                ( finalUsedNames\n                                , case canVarSelectionResult of\n                                    CanSuccess cache variantSelection ->\n                                        CanSuccess (Cache.merge newCache cache)\n                                            (Can.Field\n                                                { alias_ = Maybe.map convertName field.alias_\n                                                , name = convertName field.name\n                                                , globalAlias =\n                                                    Can.Name global.globalName\n                                                , selectsOnlyFragment = selectsSingleFragment refs field.selection\n                                                , arguments = field.arguments\n                                                , directives = List.map convertDirective field.directives\n                                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                                , selection =\n                                                    Can.FieldUnion variantSelection\n                                                }\n                                            )\n\n                                    CanError errorMsg ->\n                                        CanError errorMsg\n                                )\n\n            GraphQL.Schema.Interface name ->\n                case Dict.get name refs.schema.interfaces of\n                    Nothing ->\n                        ( usedNames, err [ error (UnionUnknown name) ] )\n\n                    Just interface ->\n                        let\n                            variants =\n                                List.foldl getInterfaceNames [] interface.implementedBy\n\n                            aliasedName =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                                    |> Can.nameToString\n\n                            global =\n                                getGlobalNameWithFragmentAlias\n                                    field.selection\n                                    aliasedName\n                                    usedNames\n\n                            ( finalUsedNames, canVarSelectionResult ) =\n                                canonicalizeVariantSelection refs\n                                    (global.used\n                                        |> UsedNames.addLevel (UsedNames.levelFromField field)\n                                    )\n                                    { name = interface.name\n                                    , description = interface.description\n                                    , fields = interface.fields\n                                    }\n                                    field.selection\n                                    variants\n                        in\n                        ( finalUsedNames\n                        , case canVarSelectionResult of\n                            CanSuccess cache variantSelection ->\n                                CanSuccess (Cache.merge newCache cache)\n                                    (Can.Field\n                                        { alias_ = Maybe.map convertName field.alias_\n                                        , name = convertName field.name\n                                        , globalAlias =\n                                            Can.Name global.globalName\n                                        , selectsOnlyFragment = selectsSingleFragment refs field.selection\n                                        , arguments = field.arguments\n                                        , directives = List.map convertDirective field.directives\n                                        , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                        , selection =\n                                            Can.FieldInterface variantSelection\n                                        }\n                                    )\n\n                            CanError errorMsg ->\n                                CanError errorMsg\n                        )\n\n            GraphQL.Schema.List_ inner ->\n                canonicalizeFieldTypeHelper refs field inner usedNames newCache schemaField\n\n            GraphQL.Schema.Nullable inner ->\n                canonicalizeFieldTypeHelper refs field inner usedNames newCache schemaField\n\n\ngatherRemaining tag ( used, gathered ) =\n    let\n        global =\n            UsedNames.getGlobalName tag used\n    in\n    ( global.used\n    , { globalAlias = Can.Name global.globalName\n      , tag = Can.Name tag\n      }\n        :: gathered\n    )\n\n\ncanonicalizeObject :\n    References\n    -> AST.FieldDetails\n    -> UsedNames.UsedNames\n    -> GraphQL.Schema.Field\n    -> Cache.Cache\n    -> GraphQL.Schema.ObjectDetails\n    -> ( UsedNames.UsedNames, CanResult Can.Field )\ncanonicalizeObject refs field usedNames schemaField varCache obj =\n    case field.selection of\n        [] ->\n            -- This is an object with no selection, which isn't allowed for gql.\n            ( usedNames\n            , err\n                [ error\n                    (EmptySelection\n                        { field =\n                            case field.alias_ of\n                                Nothing ->\n                                    AST.nameToString field.name\n\n                                Just alias ->\n                                    AST.nameToString alias\n                                        ++ \": \"\n                                        ++ AST.nameToString field.name\n                        , fieldType = obj.name\n                        , options =\n                            List.map\n                                (\\f ->\n                                    { field = f.name\n                                    , type_ = GraphQL.Schema.typeToString f.type_\n                                    }\n                                )\n                                obj.fields\n                        }\n                    )\n                ]\n            )\n\n        _ ->\n            let\n                aliasedName =\n                    field.alias_\n                        |> Maybe.withDefault field.name\n                        |> convertName\n                        |> Can.nameToString\n\n                global =\n                    getGlobalNameWithFragmentAlias field.selection\n                        aliasedName\n                        usedNames\n\n                selectionResult =\n                    List.foldl\n                        (canonicalizeField refs obj)\n                        { result = emptySuccess\n                        , fieldNames =\n                            global.used\n                                |> UsedNames.addLevel (UsedNames.levelFromField field)\n                        }\n                        field.selection\n            in\n            case selectionResult.result of\n                CanSuccess cache canSelection ->\n                    let\n                        siblingID =\n                            { aliasedName = aliasedName\n\n                            -- This is an object, not a scalar\n                            , scalar = Nothing\n                            }\n                    in\n                    if UsedNames.siblingCollision siblingID global.used then\n                        ( selectionResult.fieldNames\n                            |> UsedNames.dropLevel\n                        , err\n                            [ error\n                                (FieldAliasRequired\n                                    { fieldName = aliasedName\n                                    }\n                                )\n                            ]\n                        )\n\n                    else\n                        ( selectionResult.fieldNames\n                            |> UsedNames.dropLevel\n                            |> UsedNames.saveSibling siblingID\n                        , CanSuccess (Cache.merge varCache cache)\n                            (Can.Field\n                                { alias_ = Maybe.map convertName field.alias_\n                                , name = convertName field.name\n                                , globalAlias = Can.Name global.globalName\n                                , selectsOnlyFragment = selectsSingleFragment refs field.selection\n                                , arguments = field.arguments\n                                , directives = List.map convertDirective field.directives\n                                , wrapper = GraphQL.Schema.getWrap schemaField.type_\n                                , selection =\n                                    Can.FieldObject canSelection\n                                }\n                            )\n                        )\n\n                CanError errorMsg ->\n                    ( global.used, CanError errorMsg )\n\n\ngetInterfaceNames kind found =\n    case kind of\n        GraphQL.Schema.ObjectKind name ->\n            name :: found\n\n        _ ->\n            found\n\n\n{-| Members of a union can only be objects:\n<https://spec.graphql.org/June2018/#sec-Unions>\n\nSome more details: <https://github.com/graphql/graphql-js/issues/451>\n\n-}\nextractUnionTags : List GraphQL.Schema.Variant -> List String -> Maybe (List String)\nextractUnionTags vars captured =\n    case vars of\n        [] ->\n            Just captured\n\n        top :: remain ->\n            case top.kind of\n                GraphQL.Schema.ObjectKind name ->\n                    extractUnionTags remain (name :: captured)\n\n                _ ->\n                    Nothing\n\n\naddToResult newCache newItem result =\n    case result of\n        CanSuccess cache existing ->\n            CanSuccess (Cache.merge newCache cache) (newItem :: existing)\n\n        CanError errs ->\n            CanError errs\n\n\naddCache newCache result =\n    case result of\n        CanSuccess cache existing ->\n            CanSuccess (Cache.merge newCache cache) existing\n\n        CanError errs ->\n            CanError errs\n\n\ncanonicalizeFieldWithVariants :\n    References\n    ->\n        { obj\n            | name : String\n            , description : Maybe String\n            , fields : List GraphQL.Schema.Field\n        }\n    -> AST.Selection\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames.UsedNames\n        , variants : List String\n        , capturedVariants : List Can.VariantCase\n        , typenameAlreadySelected : Bool\n        }\n    ->\n        { result : CanResult (List Can.Field)\n        , fieldNames : UsedNames.UsedNames\n        , variants : List String\n        , capturedVariants : List Can.VariantCase\n        , typenameAlreadySelected : Bool\n        }\ncanonicalizeFieldWithVariants refs unionOrInterface selection found =\n    case selection of\n        AST.Field field ->\n            let\n                fieldName =\n                    AST.nameToString field.name\n            in\n            if fieldName == \"__typename\" then\n                { result =\n                    addToResult Cache.empty\n                        (Can.Field\n                            { alias_ = Maybe.map convertName field.alias_\n                            , name = convertName field.name\n                            , globalAlias =\n                                field.alias_\n                                    |> Maybe.withDefault field.name\n                                    |> convertName\n                            , selectsOnlyFragment = Nothing\n                            , arguments = []\n                            , directives = List.map convertDirective field.directives\n                            , wrapper = GraphQL.Schema.UnwrappedValue\n                            , selection =\n                                Can.FieldScalar (GraphQL.Schema.Scalar \"typename\")\n                            }\n                        )\n                        found.result\n                , fieldNames = found.fieldNames\n                , variants = found.variants\n                , capturedVariants = found.capturedVariants\n                , typenameAlreadySelected = True\n                }\n\n            else\n                let\n                    canned =\n                        canonicalizeField refs\n                            unionOrInterface\n                            selection\n                            { result = found.result\n                            , fieldNames =\n                                found.fieldNames\n                            }\n                in\n                { result =\n                    canned.result\n                , fieldNames = canned.fieldNames\n                , variants = found.variants\n                , capturedVariants = found.capturedVariants\n                , typenameAlreadySelected = found.typenameAlreadySelected\n                }\n\n        AST.FragmentSpreadSelection frag ->\n            let\n                fragName =\n                    AST.nameToString frag.name\n            in\n            case Dict.get fragName refs.fragments of\n                Nothing ->\n                    { result =\n                        err\n                            [ error <|\n                                FragmentNotFound\n                                    { found = fragName\n                                    , object = unionOrInterface.name\n                                    , options =\n                                        Dict.values refs.fragments\n                                    }\n                            ]\n                    , fieldNames = found.fieldNames\n                    , variants = found.variants\n                    , capturedVariants = found.capturedVariants\n                    , typenameAlreadySelected = found.typenameAlreadySelected\n                    }\n\n                Just foundFrag ->\n                    if Can.nameToString foundFrag.typeCondition == unionOrInterface.name then\n                        { result =\n                            found.result\n                                |> addToResult\n                                    (Cache.empty\n                                        |> Cache.addFragment\n                                            { fragment = foundFrag\n                                            , alongsideOtherFields = False\n                                            }\n                                    )\n                                    (Can.Frag\n                                        { fragment = foundFrag\n                                        , directives =\n                                            frag.directives\n                                                |> List.map\n                                                    convertDirective\n                                        }\n                                    )\n                        , fieldNames =\n                            found.fieldNames\n                        , variants = found.variants\n                        , capturedVariants = found.capturedVariants\n                        , typenameAlreadySelected = found.typenameAlreadySelected\n                        }\n\n                    else\n                        { result =\n                            err\n                                [ error <|\n                                    FragmentNotFound\n                                        { found = fragName\n                                        , object = unionOrInterface.name\n                                        , options =\n                                            Dict.values refs.fragments\n                                        }\n                                ]\n                        , fieldNames = found.fieldNames\n                        , variants = found.variants\n                        , capturedVariants = found.capturedVariants\n                        , typenameAlreadySelected = found.typenameAlreadySelected\n                        }\n\n        AST.InlineFragmentSelection inline ->\n            case inline.selection of\n                [] ->\n                    { result =\n                        err [ error (EmptyUnionVariantSelection { tag = AST.nameToString inline.tag }) ]\n                    , fieldNames = found.fieldNames\n                    , variants = found.variants\n                    , capturedVariants = found.capturedVariants\n                    , typenameAlreadySelected = found.typenameAlreadySelected\n                    }\n\n                _ ->\n                    let\n                        tag =\n                            AST.nameToString inline.tag\n\n                        ( tagMatches, leftOvertags ) =\n                            matchTag tag found.variants ( False, [] )\n                    in\n                    if tagMatches then\n                        case Dict.get tag refs.schema.objects of\n                            Nothing ->\n                                { result =\n                                    err [ error (ObjectUnknown tag) ]\n                                , fieldNames = found.fieldNames\n                                , variants = leftOvertags\n                                , capturedVariants = found.capturedVariants\n                                , typenameAlreadySelected = found.typenameAlreadySelected\n                                }\n\n                            Just obj ->\n                                let\n                                    selectsForTypename =\n                                        if found.typenameAlreadySelected then\n                                            True\n\n                                        else\n                                            List.any\n                                                (\\sel ->\n                                                    case sel of\n                                                        AST.Field firstField ->\n                                                            case AST.nameToString firstField.name of\n                                                                \"__typename\" ->\n                                                                    True\n\n                                                                _ ->\n                                                                    False\n\n                                                        _ ->\n                                                            False\n                                                )\n                                                inline.selection\n\n                                    selectionResult =\n                                        List.foldl\n                                            (\\sel cursor ->\n                                                canonicalizeField refs obj sel cursor\n                                            )\n                                            { result = emptySuccess\n                                            , fieldNames =\n                                                found.fieldNames\n                                                    |> UsedNames.addLevelKeepSiblingStack\n                                                        { name = tag\n                                                        , isAlias = False\n                                                        }\n                                            }\n                                            inline.selection\n                                in\n                                if selectsForTypename then\n                                    case selectionResult.result of\n                                        CanSuccess cache canSelection ->\n                                            let\n                                                global =\n                                                    UsedNames.getGlobalName tag\n                                                        (selectionResult.fieldNames\n                                                            |> UsedNames.dropLevelNotSiblings\n                                                        )\n\n                                                globalDetailsAlias =\n                                                    getGlobalNameWithFragmentAlias\n                                                        inline.selection\n                                                        (global.globalName ++ \"_Details\")\n                                                        global.used\n                                            in\n                                            { result =\n                                                found.result\n                                                    |> addCache cache\n                                            , capturedVariants =\n                                                { tag = Can.Name tag\n                                                , globalTagName = Can.Name global.globalName\n                                                , globalDetailsAlias = Can.Name globalDetailsAlias.globalName\n                                                , directives = List.map convertDirective inline.directives\n                                                , selection = canSelection\n                                                }\n                                                    :: found.capturedVariants\n                                            , fieldNames = globalDetailsAlias.used\n                                            , variants = leftOvertags\n                                            , typenameAlreadySelected = found.typenameAlreadySelected\n                                            }\n\n                                        CanError errorMsg ->\n                                            { result =\n                                                CanError errorMsg\n                                            , capturedVariants = found.capturedVariants\n                                            , fieldNames = selectionResult.fieldNames\n                                            , variants = leftOvertags\n                                            , typenameAlreadySelected = found.typenameAlreadySelected\n                                            }\n\n                                else\n                                    { result =\n                                        err [ error (MissingTypename { tag = AST.nameToString inline.tag }) ]\n                                    , fieldNames = found.fieldNames\n                                    , capturedVariants = found.capturedVariants\n                                    , variants = found.variants\n                                    , typenameAlreadySelected = found.typenameAlreadySelected\n                                    }\n\n                    else\n                        { result =\n                            err [ todo (tag ++ \" does not match!\") ]\n                        , fieldNames = found.fieldNames\n                        , variants = found.variants\n                        , capturedVariants = found.capturedVariants\n                        , typenameAlreadySelected = found.typenameAlreadySelected\n                        }\n\n\nmatchTag : String -> List String -> ( Bool, List String ) -> ( Bool, List String )\nmatchTag tag tags ( matched, captured ) =\n    case tags of\n        [] ->\n            ( matched, captured )\n\n        top :: remain ->\n            if top == tag then\n                ( True, remain ++ captured )\n\n            else\n                matchTag tag\n                    remain\n                    ( matched, top :: captured )\n"; });
