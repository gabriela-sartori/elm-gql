"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (function () { return "module GraphQL.Operations.AST exposing (..)\n\n\ntype alias Document =\n    { definitions : List Definition\n    }\n\n\ntype Definition\n    = Fragment FragmentDetails\n    | Operation OperationDetails\n\n\ntype alias FragmentDetails =\n    { name : Name\n    , typeCondition : Name\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\ntype alias OperationDetails =\n    { operationType : OperationType\n    , name : Maybe Name\n    , variableDefinitions : List VariableDefinition\n    , directives : List Directive\n    , fields : List Selection\n    }\n\n\ntype OperationType\n    = Query\n    | Mutation\n\n\ntype alias VariableDefinition =\n    { variable : Variable\n    , type_ : Type\n    , defaultValue : Maybe Value\n    }\n\n\ntype alias Variable =\n    { name : Name\n    }\n\n\ntype Selection\n    = Field FieldDetails\n    | FragmentSpreadSelection FragmentSpread\n    | InlineFragmentSelection InlineFragment\n\n\ntype alias FieldDetails =\n    { alias_ : Maybe Name\n    , name : Name\n    , arguments : List Argument\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\ntype alias FragmentSpread =\n    { name : Name\n    , directives : List Directive\n    }\n\n\ntype alias InlineFragment =\n    { tag : Name\n    , directives : List Directive\n    , selection : List Selection\n    }\n\n\ntype Name\n    = Name String\n\n\ngetAliasedName : FieldDetails -> String\ngetAliasedName deets =\n    Maybe.withDefault deets.name deets.alias_\n        |> nameToString\n\n\nnameToString : Name -> String\nnameToString (Name str) =\n    str\n\n\ntype Value\n    = Str String\n    | Integer Int\n    | Decimal Float\n    | Boolean Bool\n    | Null\n    | Enum Name\n    | Var Variable\n    | Object (List ( Name, Value ))\n    | ListValue (List Value)\n\n\nvalueToString : Value -> String\nvalueToString v =\n    case v of\n        Str str ->\n            \"\\\"\" ++ str ++ \"\\\"\"\n\n        Integer i ->\n            String.fromInt i\n\n        Decimal f ->\n            String.fromFloat f\n\n        Boolean True ->\n            \"true\"\n\n        Boolean False ->\n            \"false\"\n\n        Null ->\n            \"null\"\n\n        Enum name ->\n            nameToString name\n\n        Var variable ->\n            \"$\" ++ nameToString variable.name\n\n        Object fields ->\n            \"{ \"\n                ++ String.join \", \"\n                    (List.map\n                        (\\( name, value ) ->\n                            nameToString name\n                                ++ \": \"\n                                ++ valueToString value\n                        )\n                        fields\n                    )\n                ++ \" }\"\n\n        ListValue vals ->\n            \"[ \" ++ String.join \", \" (List.map valueToString vals) ++ \" ]\"\n\n\ntype alias Argument =\n    { name : Name\n    , value : Value\n    }\n\n\ntype alias Directive =\n    { name : Name\n    , arguments : List Argument\n    }\n\n\ntype Type\n    = Type_ Name\n    | List_ Type\n    | Nullable Type\n\n\nbrackets : String -> String\nbrackets str =\n    \"{\" ++ str ++ \"}\"\n\n\ntype Wrapper\n    = InList { required : Bool } Wrapper\n    | Val { required : Bool }\n\n\ntypeToGqlString : Type -> String\ntypeToGqlString t =\n    typeToString (getWrapper t (Val { required = True })) t\n\n\n{-|\n\n    Type ->\n        Required Val\n\n    Nullable Type ->\n        Val\n\n-}\ngetWrapper : Type -> Wrapper -> Wrapper\ngetWrapper t wrap =\n    case t of\n        Type_ _ ->\n            wrap\n\n        List_ inner ->\n            getWrapper inner wrap\n\n        Nullable inner ->\n            case wrap of\n                Val { required } ->\n                    getWrapper inner (Val { required = False })\n\n                InList { required } wrapper ->\n                    getWrapper inner (InList { required = False } wrapper)\n\n\ntypeToString : Wrapper -> Type -> String\ntypeToString wrapper t =\n    case t of\n        Type_ (Name str) ->\n            unwrap wrapper str\n\n        List_ inner ->\n            typeToString wrapper inner\n\n        Nullable inner ->\n            typeToString wrapper inner\n\n\nunwrap : Wrapper -> String -> String\nunwrap wrapper str =\n    case wrapper of\n        Val { required } ->\n            if required then\n                str ++ \"!\"\n\n            else\n                str\n\n        InList { required } inner ->\n            if required then\n                unwrap inner (\"[\" ++ str ++ \"]!\")\n\n            else\n                unwrap inner (\"[\" ++ str ++ \"]\")\n\n\n{-| Bfore canonicalizing fragments, we need to order them so that fragments with no fragments start first\n-}\nfragmentCount : FragmentDetails -> Int\nfragmentCount fragment =\n    List.foldl fragmentCountHelper 0 fragment.selection\n\n\nfragmentCountHelper : Selection -> Int -> Int\nfragmentCountHelper selection count =\n    case selection of\n        Field field ->\n            List.foldl fragmentCountHelper count field.selection\n\n        FragmentSpreadSelection spread ->\n            count + 1\n\n        InlineFragmentSelection inline ->\n            List.foldl fragmentCountHelper count inline.selection\n"; });
